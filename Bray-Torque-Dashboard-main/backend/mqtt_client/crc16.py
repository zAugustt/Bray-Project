"""
CRC16 Module

This module provides calculations for the CRC16 CCITT using high and low byte look up tables based on the firmware
implementation. This is based on Bray Firmware Version 3.2, PWA version C, `crc16.c`.

Authors:
    Aidan Queng (jaidanqueng@gmail.com), Texas A&M University

Date:
    November 2024
"""


# CRC 16-bit "low" byte table
# Table taken from `crc16.c` in firmware
crc16_tbl_lo = [
    0x00, 0x21, 0x42, 0x63, 0x84, 0xa5, 0xc6, 0xe7, # 0x08
    0x08, 0x29, 0x4a, 0x6b, 0x8c, 0xad, 0xce, 0xef, # 0x10
    0x31, 0x10, 0x73, 0x52, 0xb5, 0x94, 0xf7, 0xd6, # 0x18
    0x39, 0x18, 0x7b, 0x5a, 0xbd, 0x9c, 0xff, 0xde, # 0x20
    0x62, 0x43, 0x20, 0x01, 0xe6, 0xc7, 0xa4, 0x85, # 0x28
    0x6a, 0x4b, 0x28, 0x09, 0xee, 0xcf, 0xac, 0x8d, # 0x30
    0x53, 0x72, 0x11, 0x30, 0xd7, 0xf6, 0x95, 0xb4, # 0x38
    0x5b, 0x7a, 0x19, 0x38, 0xdf, 0xfe, 0x9d, 0xbc, # 0x40
    0xc4, 0xe5, 0x86, 0xa7, 0x40, 0x61, 0x02, 0x23, # 0x48
    0xcc, 0xed, 0x8e, 0xaf, 0x48, 0x69, 0x0a, 0x2b, # 0x50
    0xf5, 0xd4, 0xb7, 0x96, 0x71, 0x50, 0x33, 0x12, # 0x58
    0xfd, 0xdc, 0xbf, 0x9e, 0x79, 0x58, 0x3b, 0x1a, # 0x60
    0xa6, 0x87, 0xe4, 0xc5, 0x22, 0x03, 0x60, 0x41, # 0x68
    0xae, 0x8f, 0xec, 0xcd, 0x2a, 0x0b, 0x68, 0x49, # 0x70
    0x97, 0xb6, 0xd5, 0xf4, 0x13, 0x32, 0x51, 0x70, # 0x78
    0x9f, 0xbe, 0xdd, 0xfc, 0x1b, 0x3a, 0x59, 0x78, # 0x80
    0x88, 0xa9, 0xca, 0xeb, 0x0c, 0x2d, 0x4e, 0x6f, # 0x88
    0x80, 0xa1, 0xc2, 0xe3, 0x04, 0x25, 0x46, 0x67, # 0x90
    0xb9, 0x98, 0xfb, 0xda, 0x3d, 0x1c, 0x7f, 0x5e, # 0x98
    0xb1, 0x90, 0xf3, 0xd2, 0x35, 0x14, 0x77, 0x56, # 0xA0
    0xea, 0xcb, 0xa8, 0x89, 0x6e, 0x4f, 0x2c, 0x0d, # 0xA8
    0xe2, 0xc3, 0xa0, 0x81, 0x66, 0x47, 0x24, 0x05, # 0xB0
    0xdb, 0xfa, 0x99, 0xb8, 0x5f, 0x7e, 0x1d, 0x3c, # 0xB8
    0xd3, 0xf2, 0x91, 0xb0, 0x57, 0x76, 0x15, 0x34, # 0xC0
    0x4c, 0x6d, 0x0e, 0x2f, 0xc8, 0xe9, 0x8a, 0xab, # 0xC8
    0x44, 0x65, 0x06, 0x27, 0xc0, 0xe1, 0x82, 0xa3, # 0xD0
    0x7d, 0x5c, 0x3f, 0x1e, 0xf9, 0xd8, 0xbb, 0x9a, # 0xD8
    0x75, 0x54, 0x37, 0x16, 0xf1, 0xd0, 0xb3, 0x92, # 0xE0
    0x2e, 0x0f, 0x6c, 0x4d, 0xaa, 0x8b, 0xe8, 0xc9, # 0xE8
    0x26, 0x07, 0x64, 0x45, 0xa2, 0x83, 0xe0, 0xc1, # 0xF0
    0x1f, 0x3e, 0x5d, 0x7c, 0x9b, 0xba, 0xd9, 0xf8, # 0xF8
    0x17, 0x36, 0x55, 0x74, 0x93, 0xb2, 0xd1, 0xf0
]

# CRC 16-bit "high" byte table
# Table taken from `crc16.c` in firmware
crc16_tbl_hi = [
    0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, # 0x08
    0x81, 0x91, 0xa1, 0xb1, 0xc1, 0xd1, 0xe1, 0xf1, # 0x10
    0x12, 0x02, 0x32, 0x22, 0x52, 0x42, 0x72, 0x62, # 0x18
    0x93, 0x83, 0xb3, 0xa3, 0xd3, 0xc3, 0xf3, 0xe3, # 0x20
    0x24, 0x34, 0x04, 0x14, 0x64, 0x74, 0x44, 0x54, # 0x28
    0xa5, 0xb5, 0x85, 0x95, 0xe5, 0xf5, 0xc5, 0xd5, # 0x30
    0x36, 0x26, 0x16, 0x06, 0x76, 0x66, 0x56, 0x46, # 0x38
    0xb7, 0xa7, 0x97, 0x87, 0xf7, 0xe7, 0xd7, 0xc7, # 0x40
    0x48, 0x58, 0x68, 0x78, 0x08, 0x18, 0x28, 0x38, # 0x48
    0xc9, 0xd9, 0xe9, 0xf9, 0x89, 0x99, 0xa9, 0xb9, # 0x50
    0x5a, 0x4a, 0x7a, 0x6a, 0x1a, 0x0a, 0x3a, 0x2a, # 0x58
    0xdb, 0xcb, 0xfb, 0xeb, 0x9b, 0x8b, 0xbb, 0xab, # 0x60
    0x6c, 0x7c, 0x4c, 0x5c, 0x2c, 0x3c, 0x0c, 0x1c, # 0x68
    0xed, 0xfd, 0xcd, 0xdd, 0xad, 0xbd, 0x8d, 0x9d, # 0x70
    0x7e, 0x6e, 0x5e, 0x4e, 0x3e, 0x2e, 0x1e, 0x0e, # 0x78
    0xff, 0xef, 0xdf, 0xcf, 0xbf, 0xaf, 0x9f, 0x8f, # 0x80
    0x91, 0x81, 0xb1, 0xa1, 0xd1, 0xc1, 0xf1, 0xe1, # 0x88
    0x10, 0x00, 0x30, 0x20, 0x50, 0x40, 0x70, 0x60, # 0x90
    0x83, 0x93, 0xa3, 0xb3, 0xc3, 0xd3, 0xe3, 0xf3, # 0x98
    0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72, # 0xA0
    0xb5, 0xa5, 0x95, 0x85, 0xf5, 0xe5, 0xd5, 0xc5, # 0xA8
    0x34, 0x24, 0x14, 0x04, 0x74, 0x64, 0x54, 0x44, # 0xB0
    0xa7, 0xb7, 0x87, 0x97, 0xe7, 0xf7, 0xc7, 0xd7, # 0xB8
    0x26, 0x36, 0x06, 0x16, 0x66, 0x76, 0x46, 0x56, # 0xC0
    0xd9, 0xc9, 0xf9, 0xe9, 0x99, 0x89, 0xb9, 0xa9, # 0xC8
    0x58, 0x48, 0x78, 0x68, 0x18, 0x08, 0x38, 0x28, # 0xD0
    0xcb, 0xdb, 0xeb, 0xfb, 0x8b, 0x9b, 0xab, 0xbb, # 0xD8
    0x4a, 0x5a, 0x6a, 0x7a, 0x0a, 0x1a, 0x2a, 0x3a, # 0xE0
    0xfd, 0xed, 0xdd, 0xcd, 0xbd, 0xad, 0x9d, 0x8d, # 0xE8
    0x7c, 0x6c, 0x5c, 0x4c, 0x3c, 0x2c, 0x1c, 0x0c, # 0xF0
    0xef, 0xff, 0xcf, 0xdf, 0xaf, 0xbf, 0x8f, 0x9f, # 0xF8
    0x6e, 0x7e, 0x4e, 0x5e, 0x2e, 0x3e, 0x0e, 0x1e
]


def CRC16_CCITT(data: bytes) -> int:
    """
    Compute the CRC16-CCITT (0x1021) checksum for the given data using a rainbow table.
    This implementation is a copy of the firmware crc16.c implementation.

    Parameters:
        data (bytes): Data to calculate CRC for.

    Returns:
        int: The CRC16 checksum as an integer.
    """
    crc = 0xffff  # Initial CRC value

    for i, byte in enumerate(data):
        # Get low and high
        crc_low = crc & 0xff
        crc_high = crc >> 8

        # Find high byte
        index = 0xff & (crc_low ^ byte)
        new_crc_high = crc16_tbl_hi[index]

        # Find low byte (Not sure why the firmware has 2 lines of code that do the exact same thing)
        index = 0xff & (crc_low ^ byte)

        # Set new values
        crc_low = 0xff & (crc16_tbl_lo[index] ^ crc_high)
        crc_high = new_crc_high

        # Recombine high and low
        crc = crc_high << 8 | crc_low

    return crc


if __name__ == "__main__":
    f = lambda x: hex(x)
    data = [0x00, 0x0a, 0x00, 0x1b, 0x00, 0x2c, 0x00, 0x3d, 0x00, 0x4e]
    # print([f(x) for x in data])
    result = CRC16_CCITT(bytes(data))
    print(result)  # Output should be 1548
    print(hex(result))  # Output should be 0x060c
